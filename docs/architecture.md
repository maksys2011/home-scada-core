# Home-SCADA — Architecture

## 1. Общая идея
Home-SCADA — это модульное ядро системы автоматизации.
Система построена как последовательный поток данных:

Source → Sensor → SensorState → Rule → Actuator
                         ↘ Logger / Archive

Каждый слой имеет чёткую ответственность и не знает лишнего.

---

## 2. Жизненный цикл приложения
Основная точка входа — класс `App`.

Типовой цикл работы:

Инициализация всех компонентов
Периодический тик:
   - обновление сенсоров
   - выполнение правил автоматики
   - Завершение работы и освобождение ресурсов

```
App::run()
 └── while (running)
      ├── Sensor::update()
      ├── RuleEngine::evaluate()
      └── wait / sleep
```     

## 3. Жизненный цикл приложения
Назначение:
Source — абстракция источника "сырого" значения.

Ответственность:
- генерация или получение значения
- не содержит логики валидации
- не знает о состояниях (OK / WARN / ALARM)

Характеристика:
- stateless или минимальное состояние
- вызывается строго из Sensor

Примеры:
- TestSource — детерминированные данные (тесты)
- RandomSource — случайные значения
- SmoothRandomSource — плавное изменение

## 4. Sensor
Назначение:
Sensor — связующее звено между Source и SensorState.

Ответственность:
- запрашивает значение у Source
- передаёт значение в SensorState
- не принимает решений

Инвариант:
Sensor не содержит бизнес-логики.

## 5. SensorState
Назначение:
SensorState — центральная точка принятия решений о состоянии сенсора.

Ответственность:
- валидация входного значения
- классификация состояния (OK / WARN / ALARM)
- deadband
- hysteresis
- debounce
- генерация событий

Инвариант:
Только SensorState имеет право менять состояние сенсора.

Выход:
- текущее состояние
- подтверждённое значение
- события для Logger и Archive

## 6. Автоматика (Rule)
Назначение:
Rule — атомарное правило автоматики.

Ответственность:
- чтение состояния сенсоров
- принятие решения
- управление актуаторами

Ограничения:
- Rule не хранит историю
- Rule не знает о других правилах
- Rule не управляет временем

Пример:
RuleThermostat — управление температурой по уставкам

## 7. RuleEngine
Назначение:
RuleEngine — координатор автоматики.

Ответственность:
- хранит набор правил
- вызывает правила в фиксированном порядке
- не содержит логики

Структура:
RuleEngine
 └── vector<unique_ptr<Rule>>

Инвариант:
RuleEngine ничего не решает, он только исполняет.

## 8. Actuator
Назначение:
Actuator — исполнительное устройство.

Ответственность:
- включение / выключение
- установка значения
- хранение текущего состояния

Ограничения:
- Actuator не принимает решений
- не содержит автоматики
- управляется только из Rule

## 9. Logger и Archive
Logger:
- фиксирует события смены состояний
- пишет только подтверждённые переходы
- используется для анализа событий

Archive:
- хранит историю всех принятых значений
- используется для графиков и отчётов
- не принимает решений

## 10. Владение и память
Модель владения:
- App владеет всеми основными компонентами
- используется std::unique_ptr
- передача владения только через std::move

Запрещено:
- new / delete
- shared_ptr в ядре
- неявное владение

## 11. Расширение системы
Система расширяется без изменения ядра:
- новые Rule
- новые Source
- новые Actuator
- UI (Qt) как внешний слой




