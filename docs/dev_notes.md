# SmartHome MiniSCADA — Dev Notes
Инженерный блокнот разработчика  
(заметки для себя, чтобы не забывать принятые решения, ошибки и выводы)

---

## Общие принципы проекта

- Проект пишется как учебно-боевой SCADA-проект
- Цель — понятная архитектура, а не «быстро работает»
- Один класс = один владелец ресурса
- Минимум скрытой магии, максимум явной логики
- Каждый модуль доводится до стабильного состояния перед переходом дальше
- Любое архитектурное решение должно быть объяснимо словами

---

## Текущий рабочий вертикальный срез

SmoothRandomSource
↓
Sensor
↓
SensorState
↓
Logger / Archive


Этот поток **работает и проверен**.

---

## SmoothRandomSource

### Назначение

Источник аналоговых данных с **плавным изменением значений**  
(имитация температуры, давления и других физических величин).

---

### Итоговая модель

Используется модель **random walk**:
- каждое новое значение = предыдущее + небольшая дельта
- дельта ограничена по величине
- значение ограничено по диапазону (min / max)

---

### Ключевые архитектурные решения

- Source **хранит состояние** (`current_`)
- Генерируется **дельта**, а не абсолютное значение
- Используется одно распределение — по дельте
- Ограничения min/max выполняются через clamp, а не через ранний return

---

### реализовал архив Archive

- Архив записывает все валидные значения датчиков
- Формат хранения данных — CSV
- Архив не фильтрует события по состояниям (OK / WARN / ALARM), а хранит историю значений
- Фильтрация значений выполняется на уровне SensorState (deadband)

Archive:
- writes every accepted sensor value
- independent from state transitions


### по состоянию на 04.01.2026

Что было сделано

В этом этапе была завершена сборка и стабилизация инициализации приложения App.
App теперь явно владеет всеми ключевыми компонентами системы (Sensor, Actuator, RuleEngine, RuleThermostat, Logger, Archive, Source) и управляет их жизненным циклом. Конфигурация правила термостата (RuleThermostatConfig) хранится как значение, а не указатель, и передаётся в правило по ссылке, что исключает проблемы с временем жизни объектов.

Также была корректно связана цепочка:

Source → Sensor → SensorState → RuleThermostat → Actuator и подтверждено корректное распространение значений сенсора в правило и далее в актуатор.

Какие проблемы возникали

Основная сложность была связана с моделью владения и временем жизни объектов.
Конфигурация RuleThermostatConfig ранее передавалась через временные объекты или указатели, что приводило к неинициализированным значениям порогов (мусор в памяти) и некорректному поведению логики правила.
Дополнительно путаницу вносило смешение ролей:
валидация допустимых значений сенсора,
логика аварий/предупреждений,
логика управления актуатором по правилам.
После разделения ответственности стало ясно, что:
SensorConfig отвечает только за корректность измерений,
RuleThermostatConfig — за управляющие уставки,
RuleThermostat — за принятие решений,
App — за владение и связывание компонентов.

Итог:

В результате архитектура стала стабильной, предсказуемой и расширяемой.
Текущая реализация считается рабочим базовым вертикальным срезом автоматики (термостат), на который дальше можно безопасно наслаивать гистерезис, ручное управление, дополнительные правила и UI.

